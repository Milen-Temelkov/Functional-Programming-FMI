# Условия

1. Дефинирайте функция `(sum l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    Няма разлика, тъй като `sum` само обхожда списъка, без да го променя.
</details>

```scheme
(sum '(1 2 3)) ;; => 6
```

2. Дефинирайте функция `(map f l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    Заради сигнатурата на `foldr` и `foldl` е по-удачно да се използва `foldr`.
    Понеже и в двете функции се използва оператора `cons`, който 
    приема атом и списък, след приключване на `foldr` списъкът ще
    е правилно подреден, докато при `foldl` списъкът ще е в обратен ред
    и ще трябва да се обърне, което е бавна операция.
</details>

```scheme
(map (lambda (x) (* x 2)) '(1 2 3)) ;; => '(2 4 6)
```

3. Дефинирайте функция `(filter p l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    Също като при `map` и тук е по-удачно да се използва
    `foldr`, за да не се налага да се обръща списъка. 
</details>

```scheme
(filter odd? '(1 2 3 4 5)) ;; => '(1 3 5)
```

4. Дефинирайте функциите `(foldr1 op l)` и `(foldl1 op l)`, които са подобни на `foldr`/`foldl`, но не приемат първичен елемент (гърмят при празен списък)

```scheme
(foldr1 + '(1 2 3)) ;; => (1 + (2 + 3))
(foldl1 + '(1 2 3)) ;; => ((1 + 2) + 3)
```

5. Дефинирайте функция `(len l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    Няма разлика, тъй като `len` само обхожда списъка, без да го променя.
</details>

```scheme
(len '())      ;; => 0
(len '(123))   ;; => 1
(len '(1 2 3)) ;; => 3
```

6. Дефинирайте функциите `(any? p l)` и `(all? p l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    Няма разлика, тъй като и двете функции само обхождат списъка, без да го променят.
</details>

```scheme
(any? odd? '(1 2 3 4 5)) ;; => #t
(any? odd? '(2 4 6))     ;; => #f

(all? even? '(1 2 3 4 5)) ;; => #f
(all? even? '(2 4 6))     ;; => #t
```

7. Дефинирайте функция `(reverse l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    Тук е по-удачно да се използва `foldl`, тъй като
    тя е предназначена за обратни задачи каквато е `reverse`.
    Ако се използва `foldr` ще е нужно на всяка стъпка да се 
    Използва `append`, което е бавна операция.
</details>

```scheme
(reverse '(1 2 3)) ;; => '(3 2 1)
```

8. Дефинирайте функция: 
- `(take n l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    Тъй като `take` взима елементи само от началото на списъка
    е по-добре да се ползва `foldl` тъй като след като сме взели
    нужният брой елементи може да спрем да залепяме такива накрая на списъка.
    В края само ще трябва да завъртим списъка.
</details>

```scheme
(take 5 '(1 2 3 4 5 6 7 8 9 10)) ;; => '(1 2 3 4 5)
(take 0 '(1 2 3)) ;; => '()
(take 5 '(1 2 3)) ;; => '(1 2 3)
```

- `(drop n l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    В този случай искаме да махнем определен брой елементи от началото.
    Това е същото като да достигнем определена дължина на опашката
    на списъка. Това може да стане по-бързо със `foldr`. Ако се използва
    `foldl` ще трябва да се подаде обърнатият списък.
</details>

```scheme
(drop 5 '(1 2 3 4 5 6 7 8 9 10)) ;; => '(6 7 8 9 10)
(drop 0 '(1 2 3)) ;; => '(1 2 3)
(drop 5 '(1 2 3)) ;; => '()
```

9.  Дефинирайте функция:
- `(takeWhile p? l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    Тъй като тази функция ще остави само определен брой елементи
    в началото е по-добре да се използва `foldr`, защото след първото 
    срещане на елемент неотговарящ на условието можем просто да 
    сложим празен списък в края.
</details>

```scheme
(takeWhile (lambda (x) (> x 5)) '(8 7 6 5 4 3)) ;; => '(8 7 6)
(takeWhile odd? '(2 1 1 1 1)) ;; => '()
```

- `(dropWhile p? l)` чрез `foldr`/`foldl` (има ли значение?)

<details>
  <summary>Разлика</summary>
    Функция прави точно обратното на горната. Тя премахва елементи в 
    началото, следователно е по-добре да се използва `foldl`, тъй като
    може в началото да се слага празен списък докато не срещнем елемент,
    който не отговаря на условието. В края ще трябва да завъртим списъка. 
</details>

```scheme
(dropWhile (lambda (x) (> x 5)) '(8 7 6 5 4 3)) ;; => '(5 4 3)
(dropWhile odd? '(2 1 1 1 1)) ;; => '(2 1 1 1 1)
```

10. Дефинирайте функция:

- `(zip l1 l2)`

```scheme
(zip '(1 2 3) '("a" "b" "c")) ;; => '((1 . "a") (2 . "b") (3 . "c"))
(zip '(1 2) '(3 4 5 6 7)) ;; => '((1 . 3) (2 . 4))
```

- `(zipWith f l1 l2)`

```scheme
(zipWith + '(1 2 3) '(5 4 2)) ;; => '(6 6 5)
```